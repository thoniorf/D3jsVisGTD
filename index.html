<!DOCTYPE html>
<html>

<head>
  <title>GTD - BD18</title>
  <meta charset="utf-8">
  <script src="https://cdn.polyfill.io/v2/polyfill.min.js"></script>
  <script src="lib/d3.min.js"></script>
  <style type="text/css">
    body {
      width: 100vw;
      min-width: 720px;
      margin: 25px auto;
      font-family: "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
    }

    circle:hover {
      fill-opacity: 0.8;
    }

    rect {
      fill: #4682b4;
      fill-opacity: 0.8;
    }

    rect:hover {
      fill-opacity: 1;
    }

    path {
      fill-opacity: 0.8;
    }

    .selected,
    path:hover {
      fill-opacity: 1;
    }

    .line {
      fill: none;
      stroke: steelblue;
      stroke-width: 3px;
    }

    .axis {
      font-size: smaller;
    }

    .main {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-evenly;
    }

    .chart {
      padding: 1em;
      border: 2px solid;
      flex-basis: 33%;
      margin-bottom: 1em;
    }
  </style>
</head>

<body>
  <article>
    <header>
      <h1>Global Terrorism Database Analysis</h1>
    </header>
    <p>Global Terrorism Database stores the terrorist attacks from January 1970 to December 2017. It comprehend
      different type of attacks that can be classified by the group who perpetrated the attack, by the type of victim
      such as Hospital, Civilian, Religious and many more, by the type of weapons used following a certain
      classification, by the quantity of property damage in dollars and so on. </p>
    <p>We decide to narrow down the entire database to include only the attacks from January 2014 and December 2017,
      because they include very well known European incidents like bataclan in France or like the incident of Finsbury
      park in Great Britain.</p>
    <section>
      <h1>Data overview</h1>
      <p>I am a paragraph without any real meaning, maybe next time put just some emoji, little bastard.</p>
      <p><label for="weapfilter">Weapon Filter </label><select id="weapfilter"></select></p>
      <div class="main">
        <svg id="pie" class="chart"></svg>
        <svg id="timeline" class="chart"></svg>
        <svg id="attacks_chart" class="chart"></svg>
        <svg id="targettype" class="chart"></svg>
      </div>
    </section>
  </article>
  <script type="text/javascript">

    const state = {
      data: [],
      selectedWeapType: null,
      selectedSuccess: null,
      selectedYear: null,
      selectedTarget: null,
      selectedCountry: null
      // TODO store selected survived state
    };

    d3.tsv('gtd1417.csv').then((parsed) => {
      state.data = parsed.map((row) => {
        row.country = parseFloat(row.country);
        row.success = parseInt(row.success);
        return row;
      });
      fillWeaponFilter('#weapfilter');
      updateApp();
    });



    function filterData() {
      return state.data.filter((d) => {
        if (state.selectedWeapType && d.weaptype1_txt !== state.selectedWeapType) {
          return false;
        }

        if (state.selectedSuccess != null && d.success != state.selectedSuccess) {
          return false;
        }
        if (state.selectedTarget && d.target1 !== state.selectedTarget) {
          return false;
        }
        if (state.selectedCountry && d.country_txt !== state.selectedCountry) {
          return false;
        }
        return true;
      });
    }
    function wrangleData(data) {
      var successData = d3.nest()
        .key(function (d) {
          return (d.success) ? "Successful" : "Unsuccessful";
        })
        .rollup(function (leaves) { return leaves.length })
        .entries(data)
        .sort(function (a, b) {
          return d3.descending(a.value, b.value);
        });

      var yearData = d3.nest()
        .key(function (d) { return d.iyear })
        .rollup(function (leaves) { return leaves.length })
        .entries(data)
        .sort(function (a, b) {
          return d3.descending(a.value, b.value);
        });

      var targetData = d3.nest()
        .key(function (d) { return d.target1 })
        .rollup(function (leaves) { return leaves.length })
        .entries(data)
        .sort(function (a, b) {
          return d3.descending(a.value, b.value);
        }).filter(function (value, index, array) {
          return index <= 10;
        });

      var countriesData = d3.nest()
        .key(function (d) { return d.country_txt })
        .rollup(function (leaves) { return leaves.length })
        .entries(data)
        .sort(function (a, b) {
          return d3.descending(a.value, b.value);
        }).filter(function (value, index, array) {
          return index <= 10;
        });

      return { successData, yearData, targetData, countriesData };
    }

    const attacksBarChar = createBarChart('#attacks_chart', "Top countries by attacks number", "Attacks number", 'selectedCountry');
    const pieChart = createPieChart('#pie', 'selectedSuccess', d3.schemeSet3.slice(2));
    const timeline = createTimeLine('#timeline', d3.schemeSet3.slice(2))
    const targetchart = createBarChart('#targettype', "Top target types by attacks number", "Attacks number", 'selectedTarget');

    function updateApp() {
      console.log("Data source fetched");
      console.log(state)
      var filtered = filterData();
      var { successData, yearData, targetData, countriesData } = wrangleData(filtered);
      attacksBarChar(countriesData);
      pieChart(successData);
      timeline(yearData);
      targetchart(targetData);
    }

    function fillWeaponFilter(element_id) {
      var nestedStateData = d3.nest()
        .key((d) => d.weaptype1_txt)
        .entries(state.data);
      d3.select(element_id).selectAll('option')
        .data(nestedStateData, (d) => d.key)
        .enter()
        .append('option')
        .attr('value', (d) => d.key)
        .text((d) => d.key);
    }


    function createPieChart(element_id, stateAttr, colorSchema) {
      const margin = { top: 30, bottom: 10, left: 60, right: 10 };
      const width = 300;
      const height = 300;
      const radius = Math.min(width, height) / 2;

      var svg = d3.select(element_id)
        .style('min-width', width + margin.left + margin.right)
        .style('min-heigt', height + margin.top + margin.bottom)
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

      svg.append('text')
        .attr('x', (width / 2) + margin.left)
        .attr('y', margin.top / 2)
        .attr('text-anchor', 'middle')
        .text('Successful and Unsuccessfull attacks number');

      var chart = svg.append('g')
        .attr('transform', `translate(${width / 2 + margin.left},${height / 2 + margin.top})`);

      var pie = d3.pie().value((d) => d.value).sortValues(null).sort(null);
      var arc = d3.arc().outerRadius(radius).innerRadius(0);
      var pieColors = d3.scaleOrdinal(colorSchema);
      const noSlice = [
        { startAngle: 0, endAngle: Math.PI * 2, padAngle: 0 },
        { startAngle: 0, endAngle: 0, padAngle: 0 }
      ];
      function update(nestedStateData) {

        var pied = pie(nestedStateData);

        pieColors.domain(nestedStateData.map((d) => d.key));

        var old = chart.selectAll('path').data();
        var path = chart.selectAll('path')
          .data(pied, (d) => d.data.key);

        var path_enter = path.enter().append('path')
          .attr('d', (d, i) => arc(noSlice[i]))
          .style('stroke', 'white');
        path_enter.on('click', (d) => {
          var boolValue = (d.data.key === "Successful") ? 1 : 0;
          if (state[stateAttr] === boolValue) {
            state[stateAttr] = null;
          } else {
            state[stateAttr] = boolValue;
          }
          updateApp();
        });

        path_enter.append('title');

        function tweenArc(d, i) {
          const interpolate = d3.interpolateObject(old[i], d);
          return (t) => arc(interpolate(t));
        }
        path.merge(path_enter)
          .classed('selected', (d) => d.data.key === state[stateAttr])
          .transition()
          .attrTween('d', tweenArc)
          .style('fill', (d) => pieColors(d.data.key));

        path.merge(path_enter).select('title')
          .text(function (d) {
            return `${d.data.key} : ${d.data.value}`;
          });
        path.exit()
          .transition()
          .attrTween('d', tweenArc)
          .remove();
      }

      return update;
    }

    function createTimeLine(element_id, color_schema) {
      const margin = { top: 20, bottom: 20, left: 80, right: 10 };
      const width = 500;
      const height = 300;
      const radius = 5;

      var svg = d3.select(element_id)
        .style('min-width', width + margin.left + margin.right)
        .style('min-heigt', height + margin.top + margin.bottom)
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

      svg.append('text')
        .attr('x', width / 2 + margin.left)
        .attr('y', margin.top / 1.5)
        .attr('text-anchor', 'middle')
        .text('Attacks number timeline')

      svg.append('text')
        .attr('x', -height / 2)
        .attr('y', margin.right * 2)
        .attr('text-anchor', 'middle')
        .attr('transform', 'rotate(-90)')
        .text('Attacks number')

      var chart = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`)

      var yScale = d3.scaleLinear().range([height, 0])
      var xScale = d3.scaleBand().range([0, width]).padding(1);
      // var color = d3.scaleOrdinal(color_schema);
      var color = d3.scaleOrdinal(['#4682b4'])
      var yAxis = d3.axisLeft(yScale);
      var xAxis = d3.axisBottom(xScale);

      var yAxisNode = chart.append('g');
      var xAxisNode = chart.append('g').attr('transform', `translate(0, ${height})`);

      var line = d3.line().x((d) => xScale(d.key)).y((d) => yScale(d.value)).curve(d3.curveMonotoneX);

      function update(nestedStateData) {
        var t = d3.transition()
          .duration(750);

        var maxLength = d3.max(nestedStateData, (d) => d.value);

        yScale.domain([0, maxLength]);
        xScale.domain(nestedStateData.map(function (d) {
          return d.key;
        }));
        color.domain([0, 1]);

        yAxisNode.transition(t).call(yAxis);
        xAxisNode.transition(t).call(xAxis);

        var lines = chart.selectAll('.line').data(nestedStateData)
          .attr('class', 'line');


        var lines_enter = lines.enter().append("path")
          .attr("class", "line")
          .attr("d", line(nestedStateData))
          .style('stroke', color(0));

        lines.merge(lines_enter).transition(t)
          .attr("d", line(nestedStateData))
          .style('stroke', color(0))

        var circles = chart.selectAll('circle').data(nestedStateData);
        var circles_enter = circles.enter().append('circle')
          .attr('class', 'circle')
          .style('stroke', color(0))
          .style('fill', color(0))
          .attr('cx', (d) => xScale(d.key))
          .attr('cy', (d) => yScale(d.value))
          .attr('r', radius);
        circles_enter.append('title');

        circles.merge(circles_enter).transition(t)
          .attr('class', 'circle')
          .style('stroke', color(0))
          .style('fill', color(0))
          .attr('cx', (d) => xScale(d.key))
          .attr('cy', (d) => yScale(d.value))
          .attr('r', radius);
        circles.merge(circles_enter).select('title').text((d) => d.value)

        lines.exit().remove()
        circles.exit().remove();
      }

      return update;
    }

    function createBarChart(element_id, top_title, left_title, stateAttr) {
      const margin = { top: 30, bottom: 120, left: 80, right: 10 };
      const width = 500;
      const height = 300;

      var svg = d3.select(element_id)
        .style('min-width', width + margin.left + margin.right)
        .style('min-heigt', height + margin.top + margin.bottom)
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

      svg.append('text')
        .attr('x', width / 2 + margin.left)
        .attr('y', margin.top / 2)
        .attr('text-anchor', 'middle')
        .text(top_title)
      svg.append('text')
        .attr('x', -height / 2)
        .attr('y', margin.right * 2)
        .attr('text-anchor', 'middle')
        .attr('transform', 'rotate(-90)')
        .text(left_title)

      var chart = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

      var yScale = d3.scaleLinear().range([height, 0]);
      var xScale = d3.scaleBand()
        .range([0, width])
        .padding(0.02);

      var yAxis = d3.axisLeft(yScale);
      var xAxis = d3.axisBottom(xScale);

      var yAxisNode = chart.append('g');
      var xAxisNode = chart.append('g').attr('transform', `translate(0, ${height})`);

      function update(nestedStateData) {

        var t = d3.transition()
          .duration(750);

        var maxLength = d3.max(nestedStateData, (d) => d.value);

        yScale.domain([0, maxLength]);
        xScale.domain(nestedStateData.map(function (d) {
          return d.key;
        }));

        yAxisNode.transition(t).call(yAxis);
        xAxisNode.transition(t).call(xAxis);
        xAxisNode.selectAll('text')
          .style('text-anchor', 'start')
          .attr('dx', 10)
          .attr('dy', -5)
          .attr('transform', 'rotate(90)');


        var bars = chart.selectAll('rect').data(nestedStateData);
        var bars_enter = bars.enter().append('rect')
          .attr('x', (d) => xScale(d.key))
          .attr('y', (d) => yScale(d.value))
          .attr('height', (d) => height - yScale(d.value))
          .attr('width', xScale.bandwidth());
        bars_enter.on('click', (d) => {
          if (state[stateAttr] === d.key) {
            state[stateAttr] = null;
          } else {
            state[stateAttr] = d.key;
          }
          updateApp();
        });
        bars_enter.append('title');

        bars.merge(bars_enter).transition(t)
          .attr('x', (d) => xScale(d.key))
          .attr('y', (d) => yScale(d.value))
          .attr('height', (d) => height - yScale(d.value))
          .attr('width', xScale.bandwidth());
        bars.merge(bars_enter).select('title').text((d) => d.value);
        bars.exit().remove();

      }

      return update;
    }

    d3.select('#weapfilter').on('change', function () {
      var selected = d3.select(this).property('value');
      state.selectedWeapType = selected;
      updateApp();
    });
  </script>
</body>

</html>