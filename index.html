<!DOCTYPE html>
<html>

<head>
  <title>GTD - BD18</title>
  <meta charset="utf-8">
  <script src="https://cdn.polyfill.io/v2/polyfill.min.js"></script>
  <script src="lib/d3.min.js"></script>
  <style type="text/css">
    body {
      width: 100vw;
      min-width: 720px;
      margin: 25px auto;
      font-family: "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
    }

    rect {
      fill: steelblue;
      fill-opacity: 0.8;
    }

    rect:hover {
      fill-opacity: 1;
    }

    path {
      fill-opacity: 0.8;
    }

    .selected,
    path:hover {
      fill-opacity: 1;
    }

    .line {
      fill: none;
      stroke: steelblue;
      stroke-width: 3px;
    }

    .axis {
      font-size: smaller;
    }

    .main {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-evenly;
    }

    .chart {
      padding: 1em;
      border: 2px solid;
      flex-basis: 33%;
      margin-bottom: 1em;
    }
  </style>
</head>

<body>
  <article>
    <header>
      <h1>Global Terrorism Database Analysis</h1>
    </header>
    <p>Global Terrorism Database stores the terrorist attacks from January 1970 to December 2017. It comprehend
      different type of attacks that can be classified by the group who perpetrated the attack, by the type of victim
      such as Hospital, Civilian, Religious and many more, by the type of weapons used following a certain
      classification, by the quantity of property damage in dollars and so on. </p>
    <p>We decide to narrow down the entire database to include only the attacks from January 2014 and December 2017,
      because they include very well known European incidents like bataclan in France or like the incident of Finsbury
      park in Great Britain.</p>
    <section>
      <h1>Data overview</h1>
      <p>I am a paragraph without any real meaning, maybe next time put just some emoji, little bastard.</p>
      <p><label for="weapfilter">Weapon Filter </label><select id="weapfilter"></select></p>
      <div class="main">
        <svg id="pie" class="chart"></svg>
        <svg id="timeline" class="chart"></svg>
        <svg id="attacks_chart" class="chart"></svg>
        <svg id="targettype" class="chart"></svg>
      </div>
    </section>
  </article>
  <script type="text/javascript">

    const state = {
      data: [],
      weaptype1: null
      // TODO store selected survived state
    };

    d3.tsv('gtd1417.csv').then((parsed) => {
      state.data = parsed.map((row) => {
        row.country = parseFloat(row.country);
        row.success = parseInt(row.success);
        return row;
      });
      fillWeaponFilter('#weapfilter');
      updateApp();
    });

    const attacksBarChar = createOverviewChart('#attacks_chart');
    const pieChart = createPieChart('#pie');
    const timeline = createTimeLine('#timeline')
    const targetchart = createTargetChart('#targettype');

    function updateApp() {
      console.log("Data source fetched");
      var data = filterData();
      attacksBarChar(data);
      pieChart(data);
      timeline(data);
      targetchart(data);
    }
    function filterData() {
      if (!state.weaptype1) return state.data;
      const filtered_data = state.data
        .filter((d) => {
          return d.weaptype1_txt === state.weaptype1
        });
      return filtered_data;
    }
    function fillWeaponFilter(element_id) {
      var nestedStateData = d3.nest()
        .key((d) => d.weaptype1_txt)
        .entries(state.data);
      d3.select(element_id).selectAll('option')
        .data(nestedStateData, (d) => d.key)
        .enter()
        .append('option')
        .attr('value', (d) => d.key)
        .text((d) => d.key);
    }


    function createPieChart(element_id) {
      const margin = { top: 30, bottom: 10, left: 60, right: 10 };
      const width = 300;
      const height = 300;
      const radius = Math.min(width, height) / 2;

      var svg = d3.select(element_id)
        .style('min-width', width + margin.left + margin.right)
        .style('min-heigt', height + margin.top + margin.bottom)
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

      svg.append('text')
        .attr('x', (width / 2) + margin.left)
        .attr('y', margin.top / 2)
        .attr('text-anchor', 'middle')
        .text('Successful and Unsuccessfull attacks number');

      var chart = svg.append('g')
        .attr('transform', `translate(${width / 2 + margin.left},${height / 2 + margin.top})`);

      var pie = d3.pie().value((d) => d.value).sortValues(null).sort(null);
      var arc = d3.arc().outerRadius(radius).innerRadius(0);
      var pieColors = d3.scaleOrdinal(d3.schemeSet3.slice(2));

      function update(new_data) {

        console.log(new_data)
        var nestedStateData = d3.nest()
          .key(function (d) {
            return (d.success) ? "Successful" : "Unsuccessful";
          })
          .rollup(function (leaves) { return leaves.length })
          .entries(new_data)
          .sort(function (a, b) {
            return d3.descending(a.value, b.value);
          }).filter(function (value, index, array) {
            return index < 10;
          });

        console.log(nestedStateData);

        var pied = pie(nestedStateData);

        pieColors.domain(nestedStateData.map((d) => d.key));

        var old = chart.selectAll('path').data();
        var path = chart.selectAll('path')
          .data(pied, (d) => d.key);

        var path_enter = path.enter().append('path')
          .attr('class', 'arc')
          .attr('d', arc)
          .style('stroke', 'white');

        path_enter.append('title');

        function tweenArc(d, i) {
          const interpolate = d3.interpolateObject(old[i], d);
          return (t) => arc(interpolate(t));
        }
        path.merge(path_enter)
          .transition()
          .attrTween('d', tweenArc)
          .style('fill', (d, i) => pieColors(i));

        path.merge(path_enter).select('title')
          .text(function (d) {
            return `${d.data.key} : ${d.data.value}`;
          });
        path.exit().remove();
      }

      return update;
    }

    function createTimeLine(element_id) {
      const margin = { top: 20, bottom: 20, left: 80, right: 10 };
      const width = 500;
      const height = 300;
      const radius = 4;

      var svg = d3.select(element_id)
        .style('min-width', width + margin.left + margin.right)
        .style('min-heigt', height + margin.top + margin.bottom)
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

      svg.append('text')
        .attr('x', width / 2 + margin.left)
        .attr('y', margin.top / 1.5)
        .attr('text-anchor', 'middle')
        .text('Attacks number timeline')

      svg.append('text')
        .attr('x', -height / 2)
        .attr('y', margin.right * 2)
        .attr('text-anchor', 'middle')
        .attr('transform', 'rotate(-90)')
        .text('Attacks number')

      var chart = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`)

      var yScale = d3.scaleLinear().range([height, 0])
      var xScale = d3.scaleBand().range([0, width]).padding(1);

      var yAxis = d3.axisLeft(yScale);
      var xAxis = d3.axisBottom(xScale);

      var yAxisNode = chart.append('g');
      var xAxisNode = chart.append('g').attr('transform', `translate(0, ${height})`);

      var line = d3.line().x((d) => xScale(d.key)).y((d) => yScale(d.value)).curve(d3.curveMonotoneX);

      function update(new_data) {
        var t = d3.transition()
          .duration(750);

        var nestedStateData = d3.nest()
          .key(function (d) { return d.iyear })
          .rollup(function (leaves) { return leaves.length })
          .entries(new_data)
          .sort(function (a, b) {
            return d3.descending(a.value, b.value);
          });
        var maxLength = d3.max(nestedStateData).value;
        console.log(nestedStateData)

        yScale.domain([0, maxLength]);
        xScale.domain(nestedStateData.map(function (d) {
          return d.key;
        }));

        yAxisNode.transition(t).call(yAxis);
        xAxisNode.transition(t).call(xAxis);
        xAxisNode.selectAll('text')
          .style('text-anchor', 'middle')

        var lines = chart.selectAll('.line').data(nestedStateData)
          .attr('class', 'line');


        var lines_enter = lines.enter().append("path")
          .attr("class", "line")
          .attr("d", line(nestedStateData))
          .style('stroke', 'steelblue');

        lines.merge(lines_enter).transition(t)
          .attr("d", line(nestedStateData))
          .style('stroke', 'steelblue')

        /* chart.append('path').datum(nestedStateData)
          .attr('class', 'line')
          // .style('stroke', 'steelblue')
          .attr('d', line); */

        var circles = chart.selectAll('circle').data(nestedStateData);
        var circles_enter = circles.enter().append('circle')
          .attr('class', 'circle')
          .style('stroke', 'steelblue')
          .style('fill', 'steelblue')
          .attr('cx', (d) => xScale(d.key))
          .attr('cy', (d) => yScale(d.value))
          .attr('r', radius);

        circles.merge(circles_enter).transition(t)
          .attr('class', 'circle')
          .style('stroke', 'steelblue')
          .style('fill', 'steelblue')
          .attr('cx', (d) => xScale(d.key))
          .attr('cy', (d) => yScale(d.value))
          .attr('r', radius);

        lines.exit().remove()
        circles.exit().remove();
      }

      return update;
    }

    function createTargetChart(element_id) {
      const margin = { top: 10, bottom: 120, left: 80, right: 10 };
      const width = 500;
      const height = 300;

      var svg = d3.select(element_id)
        .style('min-width', width + margin.left + margin.right)
        .style('min-heigt', height + margin.top + margin.bottom)
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

      svg.append('text')
        .attr('x', width / 2 + margin.left)
        .attr('y', margin.top * 1.5)
        .attr('text-anchor', 'middle')
        .text('Top target types by attacks number')
      svg.append('text')
        .attr('x', -height / 2)
        .attr('y', margin.right * 2)
        .attr('text-anchor', 'middle')
        .attr('transform', 'rotate(-90)')
        .text('Attacks number')

      var chart = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

      var yScale = d3.scaleLinear().range([height, 0]);
      var xScale = d3.scaleBand()
        .range([0, width])
        .padding(0.02);

      var yAxis = d3.axisLeft(yScale);
      var xAxis = d3.axisBottom(xScale);

      var yAxisNode = chart.append('g');
      var xAxisNode = chart.append('g').attr('transform', `translate(0, ${height})`);

      function update(update_data) {

        var t = d3.transition()
          .duration(750);

        var nestedStateData = d3.nest()
          .key(function (d) { return d.target1 })
          .rollup(function (leaves) { return leaves.length })
          .entries(update_data)
          .sort(function (a, b) {
            return d3.descending(a.value, b.value);
          }).filter(function (value, index, array) {
            return index <= 10;
          });
        var maxLength = d3.max(nestedStateData).value;

        yScale.domain([0, maxLength]);
        xScale.domain(nestedStateData.map(function (d) {
          return d.key;
        }));

        yAxisNode.transition(t).call(yAxis);
        xAxisNode.transition(t).call(xAxis);
        xAxisNode.selectAll('text')
          .style('text-anchor', 'start')
          .attr('dx', 10)
          .attr('dy', -5)
          .attr('transform', 'rotate(90)');


        var bars = chart.selectAll('rect').data(nestedStateData);
        var bars_enter = bars.enter().append('rect')
          .attr('x', (d) => xScale(d.key))
          .attr('y', (d) => yScale(d.value))
          .attr('height', (d) => height - yScale(d.value))
          .attr('width', xScale.bandwidth());

        bars.merge(bars_enter).transition(t)
          .attr('x', (d) => xScale(d.key))
          .attr('y', (d) => yScale(d.value))
          .attr('height', (d) => height - yScale(d.value))
          .attr('width', xScale.bandwidth());

        bars.exit().remove();

      }

      return update;
    }

    function createOverviewChart(element_id) {
      const margin = { top: 10, bottom: 120, left: 80, right: 10 };
      const width = 500;
      const height = 300;

      var svg = d3.select(element_id)
        .style('min-width', width + margin.left + margin.right)
        .style('min-heigt', height + margin.top + margin.bottom)
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

      svg.append('text')
        .attr('x', width / 2 + margin.left)
        .attr('y', margin.top * 1.5)
        .attr('text-anchor', 'middle')
        .text('Top countries by attacks number')
      svg.append('text')
        .attr('x', -height / 2)
        .attr('y', margin.right * 2)
        .attr('text-anchor', 'middle')
        .attr('transform', 'rotate(-90)')
        .text('Attacks number')

      var chart = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

      var yScale = d3.scaleLinear().range([height, 0]);
      var xScale = d3.scaleBand()
        .range([0, width])
        .padding(0.02);

      var yAxis = d3.axisLeft(yScale);
      var xAxis = d3.axisBottom(xScale);

      var yAxisNode = chart.append('g');
      var xAxisNode = chart.append('g').attr('transform', `translate(0, ${height})`);

      function update(update_data) {

        var t = d3.transition()
          .duration(750);

        var nestedStateData = d3.nest()
          .key(function (d) { return d.country_txt })
          .rollup(function (leaves) { return leaves.length })
          .entries(update_data)
          .sort(function (a, b) {
            return d3.descending(a.value, b.value);
          }).filter(function (value, index, array) {
            return index <= 10;
          });
        var maxLength = d3.max(nestedStateData).value;

        yScale.domain([0, maxLength]);
        xScale.domain(nestedStateData.map(function (d) {
          return d.key;
        }));

        yAxisNode.transition(t).call(yAxis);
        xAxisNode.transition(t).call(xAxis);
        xAxisNode.selectAll('text')
          .style('text-anchor', 'start')
          .attr('dx', 10)
          .attr('dy', -5)
          .attr('transform', 'rotate(90)');


        var bars = chart.selectAll('rect').data(nestedStateData);
        var bars_enter = bars.enter().append('rect')
          .attr('x', (d) => xScale(d.key))
          .attr('y', (d) => yScale(d.value))
          .attr('height', (d) => height - yScale(d.value))
          .attr('width', xScale.bandwidth());

        bars.merge(bars_enter).transition(t)
          .attr('x', (d) => xScale(d.key))
          .attr('y', (d) => yScale(d.value))
          .attr('height', (d) => height - yScale(d.value))
          .attr('width', xScale.bandwidth());

        bars.exit().remove();

      }

      return update;
    }

    d3.select('#weapfilter').on('change', function () {
      var selected = d3.select(this).property('value');
      state.weaptype1 = selected;
      updateApp();
    });
  </script>
</body>

</html>